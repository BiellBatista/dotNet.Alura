C#: aplique boas práticas de refatoração e torne seu código mais legível
	01 - Melhorando a legibilidade do código
		01 - Apresentação
		02 - Objetivos da aula
		03 - Apresentação do ambiente
		04 - Projeto inicial
		05 - Para saber mais: zoom no terminal embutido no Visual Studio Community 2022
		06 - Para saber mais: API - Documentação
		07 - Faça como eu fiz: extração de métodos
		08 - Nomes significativos
		09 - Parâmetro nomeado (A)
		10 - Para saber mais: parâmetros opcionais
		11 - Extração de classes
		12 - Faça como eu fiz: testes e refatoração
		13 - O que aprendemos?
	02 - Evitando código duplicado
		01 - Projeto da aula anterior
		02 - Objetivos da aula
		03 - Código duplicado na leitura de arquivo
		04 - Para saber mais: Boas práticas com lista de objetos e APIs
		05 - Faça como eu fiz: duplicidade de código
		06 - Para saber mais: Don't Repeat Yourself (DRY)
		07 - Resolvendo a documentação com atributos
		08 - Para saber mais: aplicando algumas diretrizes de design
		09 - Encapsulando (B / C)
		10 - Removendo duplicidade
		11 - Recuperando com Reflection
		12 - Estudo de caso: uso de atributos em projetos reais
		13 - O que aprendemos?
	03 - Padrões de Projeto e Command
		01 - Projeto da aula anterior
		02 - Objetivos da aula
		03 - Organizando o projeto em pastas
		04 - Faça como eu fiz: organizando o projeto em pastas
		05 - Para saber mais: hierarquia de pastas muito complexa
		06 - Identificando comportamentos comuns
		07 - Para saber mais: programação assíncrona com C#
		08 - Métodos síncronos e assíncronos (C)
		09 - Para saber mais: o que são padrões de projeto (design patterns)
		10 - Definindo comportamentos comuns (A / E)
		11 - Eliminando o Switch
		12 - Para saber mais: dicionário em C#
		13 - Desafio: classe ComandosDoSistema para encapsular a coleção de comandos do sistema
		14 - Estudo de caso: padrão Command em bibliotecas famosas
		15 - O que aprendemos?
	04 - Testes automatizados
		01 - Projeto da aula anterior
		02 - Objetivos da aula
		03 - Automatizando testes
		04 - Faça como eu fiz: adicionando projeto de testes a solução
		05 - Testando o HttpClientPet
		06 - Faça como eu fiz: testes unitários
		07 - Testando exceções
		08 - Teste uma exceção (B)
		09 - Nova refatoração com testes
		10 - Estudo de caso: bibliotecas realizam muitos testes!
		11 - Projeto da aula
		12 - O que aprendemos?
	05 - Desafios
		01 - Apresentando os desafios
		02 - Apresentando os desafios
		03 - Desafio 1
		04 - Resolução desafio 2
		05 - Desafio 2
		06 - Conclusão
C#: aprenda a criar testes limpos com boas práticas
	01 - Declarando dependências
		01 - Apresentação
		02 - Projeto inicial
		03 - Identificando dependência de classes
		04 - IHttpClientFactory
		05 - Sobre HttpClient (B)
		06 - Para saber mais: Microsoft recomenda IHttpClientFactory
		07 - Faça como eu fiz: instalando a biblioteca Moq via CLI
		08 - Simulando objetos com Moq
		09 - Usando a biblioteca Moq (A)
		10 - Testando API Fora do Ar
		11 - Testando API Fora do Ar
		12 - Desafio: criar testes de unidade para o leitor de arquivos
		13 - O que aprendemos?
	02 - Boas práticas em testes
		01 - Projeto da aula anterior
		02 - Problemas ao testar comandos
		03 - Um teste rápido
		04 - Para saber mais: testes limpos e o tal de F.I.R.S.T.
		05 - Leitor de arquivos no construtor
		06 - Teste de unidade no comando import
		07 - Data Builders
		08 - Desafio: criar testes de unidade para a importação de arquivo inexistente e criar o Data Builder para HttpClientPet
		09 - Faça como eu fiz: modificar o comando show para receber o leitor de arquivos
		10 - O que aprendemos?
	03 - Extraindo resultados
		01 - Projeto da aula anterior
		02 - Testes autoverificáveis
		03 - Testando resultados (B)
		04 - Biblioteca FluentResult
		05 - Faça como eu fiz: adicionando a biblioteca FluentResult
		06 - Representando sucesso de forma estruturada
		07 - Representando falhas
		08 - Faça como eu fiz: representando falhas nos outros comandos
		09 - Para saber mais: o padrão Result
		10 - O que aprendemos?
	04 - Isolando exibição
		01 - Projeto da aula anterior
		02 - Responsabilidade única
		03 - Princípio da Responsabilidade Única (SRP) (C / D)
		04 - Definindo a classe ConsoleUI
		05 - Exibindo os pets a partir do ConsoleUI
		06 - ConsoleUI para exibir a documentação dos comandos
		07 - Faça como eu fiz: refatorando a exibição da documentação do sistema
		08 - Para saber mais: C# Pattern Matching em expressões switch
		09 - O que aprendemos?
	05 - Fábrica de comandos
		01 - Projeto da aula anterior
		02 - A dependência com o array de argumentos
		03 - Faça como eu fiz: removendo o array de arquivos do ExecutarAsync
		04 - Resolvendo a string de argumentos
		05 - Para saber mais: o padrão Factory Method
		06 - Factory Method (E)
		07 - Desafio: criar testes para os comandos Show, List e Help
		08 - Resolução do desafio #1
		09 - Resolução do desafio #2
		10 - Resolução do desafio #3
		11 - Projeto final
		12 - O que aprendemos?
		13 - Conclusão
C#: aplique princípios SOLID
	01 - Importando Json
		01 - Apresentação
		02 - Preparando o ambiente
		03 - Testes para Json
		04 - Princípio da Inversão de Dependências (DIP)
		05 - Utilizando o padrão Strategy
		06 - Príncipio da substituição
		07 - Desafio: criar testes para o LeitorDeArquivosFactory
		08 - Onde estamos ferindo o DIP? (B)
		09 - Para saber mais: os princípios DIP e LSP no ADO.NET
		10 - O que aprendemos?
	02 - Preparando a importação de clientes
		01 - Projeto da aula anterior
		02 - Preparando o ambiente: modelo de clientes
		03 - Uma nova demanda
		04 - Para saber mais: Generics
		05 - Preparando a importação
		06 - Desafio: classe de testes para ClienteService
		07 - Leitor de clientes
		08 - O padrão Template Method
		09 - Para saber mais: Template Method
		10 - Faça como eu fiz: criar leitor de clientes Json
		11 - Desafio: criando mais testes e realizando ajustes
		12 - Reaproveitamento de código
		13 - Trabalhando o reaproveitamento de código (A)
		14 - O que aprendemos?
	03 - Importação de clientes
		01 - Projeto da aula anterior
		02 - Preparando o ambiente
		03 - Mão na massa: comando de importação de clientes
		04 - Ajustando a importação de clientes
		05 - Resolvendo a exibição
		06 - Desafio: importação via Json com defeito
		07 - Testes de mutação
		08 - Para saber mais: biblioteca Stryker.NET
		09 - Alerta! Mutantes na fábrica
		10 - Desafio: reaproveitando os testes da fábrica
		11 - O que aprendemos?
	04 - Entendendo OCP
		01 - Projeto da aula anterior
		02 - Extraindo um tipo
		03 - Eliminando o switch
		04 - Faça como eu fiz: fábrica dos outros comandos
		05 - Cadeia de responsabilidades
		06 - OCP é uma contradição?
		07 - Para saber mais: aberto e fechado ao mesmo tempo
		08 - Fixando o conceito de OCP (C / D)
		09 - O que aprendemos?
	05 - Boas práticas de configurações
		01 - Projeto da aula anterior
		02 - Configurações e Padrão Builder